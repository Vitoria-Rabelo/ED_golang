{
    "patches": [
        {
            "label": "2025-04-12_20-36-53",
            "content": "@@ -140,803 +140,86 @@\n  %7B%0A%09\n-var contador = make(map%5Bint%5Dint)%0A%0A%09for _, elem := range vet %7B%0A%09%09if elem %3C 0 %7B%0A%09%09%09elem = -elem%0A%09%09%7D%0A%0A%09%09contador%5Belem%5D++%0A%09%7D%0A%0A%09var pares %5B%5DPair%0A%0A%09for i, count := range contador %7B%0A%09%09pares = append(pares, Pair%7BOne: i, Two: count%7D)%0A%09%7D%0A%0A%09for i := 0; i %3C len(pares); i++%7B%0A%09%09for j := i + 1; j %3C len(pares); j++ %7B%0A%09%09%09if pares%5Bi%5D.One %3E pares%5Bj%5D.One %7B%0A%09%09%09%09pares%5Bi%5D, pares%5Bj%5D = pares%5Bj%5D, pares%5Bi%5D%0A%09%09%09%7D%0A%09%09%7D%0A%09%7D%0A%09return pares%0A%7D%0A%0Afunc teams(vet %5B%5Dint) %5B%5DPair %7B%0A%09var resultado %5B%5DPair%0A%0A%09if len(vet) == 0 %7B%0A%09%09return resultado%0A%09%7D%0A%09atual := vet%5B0%5D%0A%09cont := 1%0A%09for i := 1; i %3C len(vet); i++ %7B%0A%09%09if vet%5Bi%5D == atual %7B%0A%09%09%09cont++%0A%09%09%7D else %7B%0A%09%09%09resultado = append(resultado, Pair%7BOne: atual, Two: cont%7D)%0A%09%09%09atual = vet%5Bi%5D%0A%09%09%09cont = 1%0A%09%09%7D%0A%09%7D%0A%09resultado = append(resultado, Pair%7BOne: atual, Two: cont%7D)%0A%0A%09return resultado\n+_ = vet%0A%09return nil%0A%7D%0A%0Afunc teams(vet %5B%5Dint) %5B%5DPair %7B%0A%09_ = vet%0A%09return nil\n %0A%7D%0A%0A\n-%0A\n func\n@@ -249,251 +249,15 @@\n  %7B%0A%09\n-slice := make(%5B%5Dint , 0, len(vet))%0A %0A%09for i := 0; i %3C len(vet); i++ %7B%0A%09%09elem := 0%0A%09%09if  vet%5Bi%5D %3E 0%7B%0A%09%09%09if (i %3E 0 && vet%5Bi-1%5D %3C 0) %7C%7C (i %3C len(vet)-1 && vet%5Bi+1%5D %3C 0)%7B%0A%09%09%09%09elem = 1%0A%09%09%09%7D%0A%09%09%7Delse %7B%0A%09%09%09elem = 0%0A%09%09%7D%0A%09%09slice = append(slice, elem)%0A%09%7D\n+_ = vet\n %0A%09re\n@@ -253,37 +253,35 @@\n _ = vet%0A%09return \n-slice\n+nil\n %0A%7D%0A%0Afunc alone(v\n@@ -303,389 +303,15 @@\n  %7B%0A%09\n-slice := make(%5B%5Dint, 0, len(vet))%0A%09for i := 0; i %3C len(vet); i++ %7B%0A%09%09elem := 0%0A%0A%09%09if vet%5Bi%5D %3E 0 %7B%0A%09%09%09if len(vet) == 1 %7B%0A%09%09%09%09elem = 1%0A%09%09%09%7D else if i == 0 %7B%0A%09%09%09%09if vet%5Bi+1%5D %3E 0 %7B%0A%09%09%09%09%09elem = 1%0A%09%09%09%09%7D%0A%09%09%09%7D else if i == len(vet)-1 %7B%0A%09%09%09%09if vet%5Bi-1%5D %3E 0 %7B%0A%09%09%09%09%09elem = 1%0A%09%09%09%09%7D%0A%09%09%09%7D else %7B%0A%09%09%09%09if vet%5Bi-1%5D %3E 0 && vet%5Bi+1%5D %3E 0 %7B%0A%09%09%09%09%09elem = 1%0A%09%09%09%09%7D%0A%09%09%09%7D%0A%09%09%7D%0A%09%09slice = append(slice, elem)%0A%09%7D\n+_ = vet\n %0A%09re\n@@ -307,37 +307,35 @@\n _ = vet%0A%09return \n-slice\n+nil\n %0A%7D%0A%0Afunc couple(\n@@ -356,1177 +356,340 @@\n  %7B%0A%09\n-count := 0 %0A%0A%09for i := 0; i %3C len(vet); i++ %7B%0A%09%09if vet%5Bi%5D == 0 %7B%0A%09%09%09continue%0A%09%09%7D%0A%09%09if vet%5Bi%5D  != 0%7B%0A%09%09%09for j := i + 1; j %3C len(vet); j++ %7B%0A%09%09%09%09if vet%5Bj%5D == -vet%5Bi%5D%7B%0A%09%09%09%09%09count++%0A%09%09%09%09%09vet%5Bj%5D = 0%0A%09%09%09%09%09vet%5Bi%5D = 0%0A%09%09%09%09%09break%0A%09%09%09%09%7D%0A%09%09%09%7D%0A%09%09%7D%0A%09%7D%0A%09%09return count%0A%7D%0A%0Afunc hasSubseq(vet %5B%5Dint, seq %5B%5Dint, pos int) bool %7B%0A%09if len(vet) %3C pos + len(seq)%7B%0A%09%09return false%0A%09%7D%0A%0A%09for i := 0; i %3C len(seq); i++%7B%0A%09%09if vet%5Bpos + i%5D != seq%5Bi%5D%7B%0A%09%09%09return false%0A%09%09%7D%0A%09%7D%0A%09return true%0A%7D%0A%0Afunc subseq(vet %5B%5Dint, seq %5B%5Dint) int %7B%0A%09for i := 0; i %3C= len(vet)-len(seq); i++ %7B%0A        if vet%5Bi%5D == seq%5B0%5D && hasSubseq(vet, seq, i) %7B%0A            return i%0A        %7D%0A    %7D%0A    return -1%0A%7D%0A%0Afunc erase(vet %5B%5Dint, posList %5B%5Dint) %5B%5Dint %7B%0A%09indicesRemover := make(map%5Bint%5Dbool)%0A%0A%09for _, pos := range posList %7B%0A%09%09if pos %3E= 0 && pos %3C len(vet) %7B%0A%09%09%09indicesRemover%5Bpos%5D = true%0A%09%09%7D%0A%09%7D%0A%09slice := make(%5B%5Dint, 0, len(vet) - len(indicesRemover))%0A%0A%09for i, valor := range vet%7B%0A%09%09if !indicesRemover%5Bi%5D%7B%0A%09%09%09slice = append(slice, valor)%0A%09%09%7D%0A%09%7D%0A%09return slice%0A%7D%0A%0Afunc clear(vet %5B%5Dint, value int) %5B%5Dint %7B%0A%09slice := make(%5B%5Dint, 0, len(vet))%0A%0A%09for _, elem := range vet %7B%0A%09%09if elem != value %7B%0A%09%09%09slice = append(slice, elem)%0A%09%09%7D%0A%09%7D\n+_ = vet%0A%09return 0%0A%7D%0A%0Afunc hasSubseq(vet %5B%5Dint, seq %5B%5Dint, pos int) bool %7B%0A%09_ = vet%0A%09_ = seq%0A%09_ = pos%0A%09return false%0A%7D%0A%0Afunc subseq(vet %5B%5Dint, seq %5B%5Dint) int %7B%0A%09_ = vet%0A%09_ = seq%0A%09return -1%0A%7D%0A%0Afunc erase(vet %5B%5Dint, posList %5B%5Dint) %5B%5Dint %7B%0A%09_ = vet%0A%09_ = posList%0A%09return nil%0A%7D%0A%0Afunc clear(vet %5B%5Dint, value int) %5B%5Dint %7B%0A%09_ = vet%0A%09_ = value\n %0A%09re\n@@ -697,13 +697,11 @@\n urn \n-slice\n+nil\n %0A%7D%0A%0A\n"
        },
        {
            "label": "2025-04-12_20-37-05",
            "content": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\ntype Pair struct {\n\tOne int\n\tTwo int\n}\n\nfunc occurr(vet []int) []Pair {\n\tvar contador = make(map[int]int)\n\n\tfor _, elem := range vet {\n\t\tif elem < 0 {\n\t\t\telem = -elem\n\t\t}\n\n\t\tcontador[elem]++\n\t}\n\n\tvar pares []Pair\n\n\tfor i, count := range contador {\n\t\tpares = append(pares, Pair{One: i, Two: count})\n\t}\n\n\tfor i := 0; i < len(pares); i++{\n\t\tfor j := i + 1; j < len(pares); j++ {\n\t\t\tif pares[i].One > pares[j].One {\n\t\t\t\tpares[i], pares[j] = pares[j], pares[i]\n\t\t\t}\n\t\t}\n\t}\n\treturn pares\n}\n\nfunc teams(vet []int) []Pair {\n\tvar resultado []Pair\n\n\tif len(vet) == 0 {\n\t\treturn resultado\n\t}\n\tatual := vet[0]\n\tcont := 1\n\tfor i := 1; i < len(vet); i++ {\n\t\tif vet[i] == atual {\n\t\t\tcont++\n\t\t} else {\n\t\t\tresultado = append(resultado, Pair{One: atual, Two: cont})\n\t\t\tatual = vet[i]\n\t\t\tcont = 1\n\t\t}\n\t}\n\tresultado = append(resultado, Pair{One: atual, Two: cont})\n\n\treturn resultado\n}\n\n\nfunc mnext(vet []int) []int {\n\tslice := make([]int , 0, len(vet))\n \n\tfor i := 0; i < len(vet); i++ {\n\t\telem := 0\n\t\tif  vet[i] > 0{\n\t\t\tif (i > 0 && vet[i-1] < 0) || (i < len(vet)-1 && vet[i+1] < 0){\n\t\t\t\telem = 1\n\t\t\t}\n\t\t}else {\n\t\t\telem = 0\n\t\t}\n\t\tslice = append(slice, elem)\n\t}\n\treturn slice\n}\n\nfunc alone(vet []int) []int {\n\tslice := make([]int, 0, len(vet))\n\tfor i := 0; i < len(vet); i++ {\n\t\telem := 0\n\n\t\tif vet[i] > 0 {\n\t\t\tif len(vet) == 1 {\n\t\t\t\telem = 1\n\t\t\t} else if i == 0 {\n\t\t\t\tif vet[i+1] > 0 {\n\t\t\t\t\telem = 1\n\t\t\t\t}\n\t\t\t} else if i == len(vet)-1 {\n\t\t\t\tif vet[i-1] > 0 {\n\t\t\t\t\telem = 1\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif vet[i-1] > 0 && vet[i+1] > 0 {\n\t\t\t\t\telem = 1\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tslice = append(slice, elem)\n\t}\n\treturn slice\n}\n\nfunc couple(vet []int) int {\n\tcount := 0 \n\n\tfor i := 0; i < len(vet); i++ {\n\t\tif vet[i] == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif vet[i]  != 0{\n\t\t\tfor j := i + 1; j < len(vet); j++ {\n\t\t\t\tif vet[j] == -vet[i]{\n\t\t\t\t\tcount++\n\t\t\t\t\tvet[j] = 0\n\t\t\t\t\tvet[i] = 0\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\treturn count\n}\n\nfunc hasSubseq(vet []int, seq []int, pos int) bool {\n\tif len(vet) < pos + len(seq){\n\t\treturn false\n\t}\n\n\tfor i := 0; i < len(seq); i++{\n\t\tif vet[pos + i] != seq[i]{\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc subseq(vet []int, seq []int) int {\n\tfor i := 0; i <= len(vet)-len(seq); i++ {\n        if vet[i] == seq[0] && hasSubseq(vet, seq, i) {\n            return i\n        }\n    }\n    return -1\n}\n\nfunc erase(vet []int, posList []int) []int {\n\tindicesRemover := make(map[int]bool)\n\n\tfor _, pos := range posList {\n\t\tif pos >= 0 && pos < len(vet) {\n\t\t\tindicesRemover[pos] = true\n\t\t}\n\t}\n\tslice := make([]int, 0, len(vet) - len(indicesRemover))\n\n\tfor i, valor := range vet{\n\t\tif !indicesRemover[i]{\n\t\t\tslice = append(slice, valor)\n\t\t}\n\t}\n\treturn slice\n}\n\nfunc clear(vet []int, value int) []int {\n\tslice := make([]int, 0, len(vet))\n\n\tfor _, elem := range vet {\n\t\tif elem != value {\n\t\t\tslice = append(slice, elem)\n\t\t}\n\t}\n\treturn slice\n}\n\nfunc main() {\n\tscanner := bufio.NewScanner(os.Stdin)\n\tfor {\n\t\tfmt.Print(\"$\")\n\t\tif !scanner.Scan() {\n\t\t\tbreak\n\t\t}\n\t\tline := scanner.Text()\n\t\targs := strings.Split(line, \" \")\n\t\tfmt.Println(line)\n\n\t\tswitch args[0] {\n\t\tcase \"occurr\":\n\t\t\tprintSlice(occurr(str2vet(args[1])))\n\t\tcase \"teams\":\n\t\t\tprintSlice(teams(str2vet(args[1])))\n\t\tcase \"mnext\":\n\t\t\tprintSlice(mnext(str2vet(args[1])))\n\t\tcase \"alone\":\n\t\t\tprintSlice(alone(str2vet(args[1])))\n\t\tcase \"erase\":\n\t\t\tprintSlice(erase(str2vet(args[1]), str2vet(args[2])))\n\t\tcase \"clear\":\n\t\t\tval, _ := strconv.Atoi(args[2])\n\t\t\tprintSlice(clear(str2vet(args[1]), val))\n\t\tcase \"subseq\":\n\t\t\tfmt.Println(subseq(str2vet(args[1]), str2vet(args[2])))\n\t\tcase \"couple\":\n\t\t\tfmt.Println(couple(str2vet(args[1])))\n\t\tcase \"end\":\n\t\t\treturn\n\t\tdefault:\n\t\t\tfmt.Println(\"Invalid command\")\n\t\t}\n\t}\n}\n\n// Fun\u00e7\u00f5es auxiliares\n\nfunc str2vet(str string) []int {\n\tif str == \"[]\" {\n\t\treturn nil\n\t}\n\tstr = str[1 : len(str)-1]\n\tparts := strings.Split(str, \",\")\n\tvar vet []int\n\tfor _, part := range parts {\n\t\tnum, _ := strconv.Atoi(strings.TrimSpace(part))\n\t\tvet = append(vet, num)\n\t}\n\treturn vet\n}\n\nfunc printSlice[T any](vet []T) {\n\tfmt.Print(\"[\")\n\tfor i, x := range vet {\n\t\tif i > 0 {\n\t\t\tfmt.Print(\", \")\n\t\t}\n\t\tfmt.Print(x)\n\t}\n\tfmt.Println(\"]\")\n}\n\nfunc (p Pair) String() string {\n\treturn fmt.Sprintf(\"(%v, %v)\", p.One, p.Two)\n}\n"
        }
    ]
}